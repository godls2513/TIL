# 객체지향 II

## 상속
- 기존 클래스를 재사용 하여 새로운 클래스를 작성하는 것(코드의 재사용)
- 두 클래스를 부모와 자식 관계로 맺어주는 것

### 상속의 특징
- 적은 양의 코드로 새로운 클래스를 작성
- 코드의 추가 및 변경이 매우 용이
- 코드 재사용성을 높이고, 코드의 중복 제거, 프로그램의 생산성과 유지보수에 크게 기여
- 조상 클래스가 변경되면 자손 클래스에 영향 ( 반면에, 자손클래스가 변경되는 것은 조상클래스에 영향 없음 )
- 자손 클래스는 조상 클래스의 모든 멤버를 상속 받음</br>(생성자, 초기화 블럭 상속 X )
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
- 상속은 **단일 상속**만 허용한다.

### 상속 구현 방법
```java
    class Parent{}
    class Child extends Parent{}
```

## 포함
- 한 클래스의 멤버 변수를 다른 클래스 타입의 참조변수로 선언하는 것
### <클래스 간 관계 결정하기>
- 상속관계 "~은 ~이다" ( is~a )
- 포함관계 "~은 ~을 가지고있다" ( has~a )</br>(대부분의 경우 잘 모를 땐 포함)

## Object 클래스 

- 모든 클래스 상속 계층도의 최상위에 있는 조상 클래스
- 부모가 없는 클래스는 자동으로 Object를 상속받음
- 모든 클래스는 Object 클래스에 정의된 11개의 메서드를 자동으로 상속 받는다.

ex) 
|Object|
|------|
|Tv|
|SmartTv|

## 오버라이딩( overriding )
- 조상 클래스로부터 상속 받은 메서드 내용을 변경하는 것
- **오버라이딩의 조건** 

||
|-|
|접근 제어자는 조상클래스의 메서드보다 좁은 범위로 변경할 수 없다.|
|조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.|
|선언부가 조상 클래스의 메서드와 일치해야 한다.|
||

- 오버로딩 vs 오버라이딩

|||
|-|-|
|오버로딩|기존에 없는 ***새로운*** 메서드를 정의하는 것|
|오버라이딩|상속받은 메서드의 ***내용*** 을 변경하는 것|
||

## 참조변수 super( ) 
- 자손클래스에서 조상클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수
- 조상의 멤버와 자신의 멤버를 구별하는 데 사용

**super( )** - 조상의 생성자
- 조상의 생성자를 호출하는 데 사용( 생성자와 초기화 블럭은 상속이 안되므로...)
- 조상의 멤버는 조상의 생성자를 통해 초기화

ex)
```java
    class Point {
        int x, y;
        
        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    class Point3D extends Point{
        int z;
        
        Point3D(int x, int y, int z) {
        super(x,y); // 조상클래스의 생성자 호출(int x, int y)
        this.z = z; // 자신의 멤버를 초기화
    }
}
```
- 생성자는 상속 되지 않는다.


## 패키지
- 클래스 묶음
- 물리적으로 하나의 디렉토리(폴더)
- 패키지 선언</br> packge 패키지명;
- 하나의 소스파일에 ***단 한번만*** 선언
- 패키지명은 ***소문자***가 원칙

## import문 
- 클래스를 사용할 때 패키지 이름을 생략할 수 있다.
- 컴파일러에게 클래스가 속한 패키지를 알려준다.
- 선언 방법</br> import 패키지명.클래스명;</br>import 패키지명.*;
- 단축키 ctrl+shift+o

순서

|1. 패키지 문|
|-|
|2. import문|
|3. 클래스 선언|

## static import문 
- static 멤버(Static 메서드, cv)를 사용할 때, 클래스 이름을 생략하게 해줌

import static java.lang.integer;<br>
import static java.lang.Math.random();<br>
import static java.lang.System.out;<br>

~~System~~.out.println(~~Math~~.random());<br>
-> out.print(random());

```java
import static java.lang.Integer; // Integer클래스의 모든 Static메서드
import static java.lang.Math.random; //Math.random()만. 괄호 안붙임.
import static java.lang.System.out; // out만으로 참조 가능

System.out.println(Math.random());
out.println(random());
```

## 제어자 

- 클래스와 클래스 멤버(멤버변수, 메서드)에 부가적이 의미 부여
- 접근 제어자 : public, protected, (default), private
- 그 외 : static, final, abstract ...
- 하나의 대상의 여러 제어자 사용 가능( 단, 접근 제어자는 맨 왼쪽에 하나만 쓸 수 있다.)

## static ... 클래스의, 공통적인
- static은 멤버변수, 메서드, 초기화 블럭에서 사용(객체 생성없이 사용)
- static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다.

## final ... 마지막의, 변경될 수 없는
- final은 어디든 붙을 수 있다.(붙는 위치에 따라 기능이 달라짐)
1. 클래스 : 변경, 확장이 불가한 클래스, 상속 계층도의 제일 마지막, 자손이 없는 클래스
2. 변수 : 상수
3. 메서드 : 오버라이딩이 불가능한 메서드

## abstract ... 추상의, 미완성의
1. 클래스 : 클래스 앞에 붙으면 추상 메서드임을 알려줌
2. 메서드 : 구현부가 없는 추상 메서드임을 알려줌
3. abstract 클래스는 객체를 생성할 수 없고, 추상 메서드를 갖고 있으므로 상속 받아서 완성 해야함.

## 접근 제어자

|public|protected|default|private|
|------|---------|-------|-------|
접근제한 없음|같은 패키지+<br>다른 패키지의 자손|같은 패키지|같은 클래스
|

## 캡슐화와 접근 제어자

- 접근 제어자를 사용하는 이유 
   - 외부로부터 데이터를 보호하기 위해
   - 외부에 불필요한, 내부적으로 사용되는, 부분을 감추기 위해 사용

- 멤버 변수의 값을 ***읽는*** 메서드 'get멤버변수이름' - 겟터(getter)
- 멤버 변수의 값을 ***변경*** 하는 메서드 'set멤버변수이름' - 셋터(setter)

## **다형성**
***정의 - 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하는 것***

ex) CaptionTv클래스는 Tv클래스를 상속 받는다고 가정하자...

```java
    Tv t = new Tv();
    CaptionTv c = new CaptionTv(); 
    //  인스턴스는 참조 변수를 통해서만 다룰 수 있으며, 참조타입은 인스턴스 타입과 일치해야 한다. (기존)

    Tv t = new CaptionTv(); // 타입 불일치, 조상 타입의 참조변수 t로 자손 인스턴스 참조(다형성)
```

- 다형성 특징
  1. 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.
  2. 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버의 개수보다 같거나 적어야한다.
  3. 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.    
    ```java
    CaptionTv c = new Tv(); // 불가능... 3. 의 이유 때문
    ```
## 참조변수의 형변환
- 서로 상속관계에 있는 클래스 사이에서만 가능
- 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.
- 조상의 조상으로도 형변환 가능 ( Object 타입으로 형변환 가능 )
- **참조 변수의 형변환은 사용할 수 있는 멤버의 개수를 조절하기 위한 것**

```java
    class Car{}
    class FireEngine extends Car{}
    class Ambulance extends Car{}

    FireEngine f = new FireEngine();
    Car c = (Car)f; // 서로 상속관계이므로 가능
    FireEngine f2 = (FireEngine)c; // 서로 상속관계이므로 가능
    Ambulance a = (Ambulance)f; // 에러, 상속관계가 아닌 클래스 간의 형변환 불가능
```

## instanceof 연산자
- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위한 연산자
- 주로 조건문에 사용
- (참조변수 instanceof 타입) 의 형태로 사용
- boolean 값, true or false 중 하나를 반환
- 연산 결과가 true면 형변환 가능

## 여러종류의 객체를 배열로 다루기
- 조상 타입의 참조변수로 자손타입의 객체를 참조하는 것이 가능 ( 다형성 )
- 조상 타입의 참조변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있다.

## 추상 클래스
- 미완성의 설계도, 인스턴스 생성 불가
- 미완성 메서드(추상메서드)를 포함하고 있는 클래스
- **abstract** class 클래스이름{ }
- 추상클래스에도 생성자가 있으며, 멤버변수를 가질 수도 있다.

### 추상클래스의 장점
- 설계도를 쉽계 작성
- 코드 중복 제거
- 코드 관리 용이
- 구체화된 코드보다 유연함(변경에 유리)

## 추상 메서드
- 선언부만 작성하고 구현부는 없는 메서드
- 추상 메서드 작성전에 주석을 달아 어떤 목적으로 만들었는지 설명하는 센스
```java
/* 어떤 목적으로 만들었는지? */
abstract 리턴타입 메서드이름 ();
```
- 자손클래스에서 오버라이딩 해 추상메서드 구현, 하나라도 구현하지 않으면 맨 앞에 abstract를 붙여서 추상클래스로 지정

## 인터페이스
- 추상 메서드의 집합
- 구현된 것이 아무것도 없는 "기본 설계도"
- 오직 추상메서드와 상수만을 멤버로 가짐, 자체적으로 인스턴스 생성 불가

```java
    interface 인터페이스이름 {
        public static final 타입 상수이름 = 값; // public static final 생략가능
        public abstract 메서드이름(매개변수목록); // public abstract 생략 가능
    // 단, static메서드와 디폴트 메서드 예외(JDK1.8부터)
    }
```
### 인터페이스의 상속
- 인터페이스는 인터페이스로부터만 상속( Object가 조상이 아님 )
- 다중 상속이 가능하다.( 추상메서드는 충돌해도 문제가 없음)

### 인터페이스의 구현
- class 클래스이름 **implements** 인터페이스이름 { //인터페이스에 정의된 추상메서드 ***모두*** 구현 }
- 일부만 구현 한다면 abstract를 붙여 추상클래스로 선언해야함
- 상속과 구현 동시에 가능<br>
class 클래스이름 ***extends*** 조상클래스이름 **implemets** 인터페이스이름{ 구현 }

### 인터페이스를 이용한 다형성
- 해당 인터페이스 타입의 참조변수로, 구현한 클래스의 인스턴스 참조 가능
- 인터페이스 타입으로 형변환 가능
- 메서드의 ***매개변수의 타입*** 으로도 사용가능 
- 인터페이스 타입의 매개변수는 인터페이스를 구현한 클래스의 객체만 가능
- 인터페이스를 메서드의 리턴타입으로 지정할 수 있다 -> 안맞으면 형변환
- ### ***리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.***

### 인터페이스의 장점
- 개발 시간 단축, 변경에 유리한 설계 가능
- 표준화 가능 ex) JDBC(인터페이스 집합)
- 서로 관계없는 클래스들에게 관계를 맺어줄 수 있음
- 독립적인 프로그래밍이 가능
- 두 대상 <객체>간의 ***연결, 대화, 소통*** 을 돕는 **중간역할**
- 선언과 구현을 분리할 수 있다.














